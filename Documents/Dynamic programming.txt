1: Cái túi
dp[i][j]: Giá trị khi có i đồ vật nhưng trọng <= j

base: dp[0][j] = 0, mọi j
dp[i][j] = dp[i - 1][j], với j < W[i]
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - W[i]]), với j >= W[i]
_____________________________________________________________________________________________________________________________________________________

2: Xâu con chung dài nhất
dp[i][j]: Độ dài xâu con chung dài nhất chỉ số i của s1, chỉ số j của s2

base: dp[i][i] = 1, mọi i
Với s1[i - 1] != s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1;
    s1[i - 1] == s2[j - 1]: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
_____________________________________________________________________________________________________________________________________________________

3: LIS (O(N^2))
L[i]: Độ dài dãy con tăng lớn nhất từ a_1 -> a_i

L[0] = 1
for i:= 1 to n do
    L[i]:=1;
    for j:=1 to i-1 do
        if (A[j]<=A[i]) and (L[i]<L[j]+1) then L[i]:=L[j]+1;

* Cải tiến O(NlogN): LIS + binary search
Code: Contest_ICPC_2025\Contest_1\D.cpp
_____________________________________________________________________________________________________________________________________________________

4: Hình vuông toàn 1 lớn nhất: 1 <= n, m <= 500
Nếu a[i][j] = 1: Nếu a[i - 1][j] = a[i][j - 1] = a[i - 1][j - 1] = 1: dp[i][j] = min(dp[i - 1][j], d[i][j - 1], dp[i - 1][j - 1]) + 1
                 Nếu không: dp[i][j] = 1
Nếu a[i][j] khác 1: dp[i][j] = 0
ans = max(dp[i][j])
_____________________________________________________________________________________________________________________________________________________

5: Prefix Sum 2D:
dp[i][j]: Tổng các phần tử trong hcn từ ô (1, 1) -> (i, j)
dp[i][j] = dp[i][j - 1] + dp[i - 1][j] + a[i][j] - dp[i - 1][j - 1]
sum: Tổng các phần tử trong hcn từ ô (i, j) -> (u, v)
sum = dp[u][v] + dp[i - 1][j - 1] - dp[u][j - 1] - dp[i - 1][v]
_____________________________________________________________________________________________________________________________________________________


